---
title: "Oranzees model (02)"
author: "Alberto Acerbi"
output:
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This R markdown file documents the development of the Oranzees model (it continues from [01-oranzees.html](01-oranzees.html)). The code-only version to run the model is in the file [main.R](main.R) in the same repository.

## Food-related behaviours

Now that we had implemented the social behaviours, we can work on the food-related ones. As before, we need to define how the state of an oranzee influences its probability to innovate. First, we want that the two nutrients Y and Z are balanced. Here is a way to implement this:

```{r}
N <- 100
pop <- matrix(c(rep(0, 38 * N), sample(1:300, N, replace = TRUE)), nrow = N, byrow = FALSE)
```

We first rebuild our basic population, and then we use a similar strategy that we used for the social behavior. In the previous case the optimal state was to have at least one behaviour in all categories, now is to have the same amount of behaviours in the two nutrients. Thus, for the individual $1$ in the population:

```{r}
nut_y <- sum(pop[1, 17:20]) + sum(pop[1, 25:27]) + sum(pop[1, 31:32]) + pop[1, 35] + pop[1, 37]
nut_z <- sum(pop[1, 21:24]) + sum(pop[1, 28:30]) + sum(pop[1, 33:34]) + pop[1, 36] + pop[1, 38]

state <- 1 - abs(nut_y - nut_z) / 5
```

The value of $state$ is calculated by comparing how many behaviours an oranzees has that provide nutrient Y and how many the provided nutrient Z. Is then divided by 5, which is the maximum possible unbalance (all Y and no Z or viceversa, in which case $state=0$). If an oranzee, for example, has one behaviours providing Y and two providing Z, its state will be:

```{r}
state <- 1 - abs(1 - 2) / 5
state
```

Beside balancing nutrients, however, oranzees need to eat something. We can add in the $state$ calculation a part that rewards oranzees for having more food.

```{r}
nut_y <- sum(pop[1, 17:20]) + sum(pop[1, 25:27]) + sum(pop[1, 31:32]) + pop[1, 35] + pop[1, 37]
nut_z <- sum(pop[1, 21:24]) + sum(pop[1, 28:30]) + sum(pop[1, 33:34]) + pop[1, 36] + pop[1, 38]
state <- (sum(nut_y + nut_z) - abs(nut_y - nut_z)) / 10
```

Everything is similar as before, but now the 'unbalance' value is not subtracted from $1$, but from the total amount of foodstuff, and all divided by the maximum possible amount, i.e. $10$.

Using the same example (an oranzee with one behaviour providing Y and two providing Z), the state will be:

```{r}
state <- ((1 + 2) - abs(1 - 2)) / 10
```

***

## Population dynamics

Let's initialise again the environment, using as before, for the mock-up population, the values for ‘Uossob’ (remember the code for the function `set_oranzees_environment()` is in the previous document, so we call it here with the option `echo=FALSE`, meaning that is run, but not shown in the html document).

```{r echo=FALSE, message=FALSE}
library(tidyverse)

set_oranzees_environment <- function() {
  list_pop <- c("Uossob", "Iat Forest", "Ebmog", "Elaham", "Elabik", "Ognodub")
  output <- tibble(
    population = rep(list_pop, each = 38),
    behaviour = as.factor(rep(1:38, 6)),
    type = rep(c(rep("social", 16), rep("food-related", 22)), 6),
    category = rep(c(
      rep("play", 4), rep("display", 4), rep("groom", 4), rep("courthsip", 4),
      "A", "A", "A", "A", "B", "B", "B", "B", "C", "C", "C", "D", "D", "D", "E", "E", "F", "F", "G", "H", "I", "J"
    ), 6),
    nutrient = rep(c(rep(NA, 16), "Y", "Y", "Y", "Y", "Z", "Z", "Z", "Z", "Y", "Y", "Y", "Z", "Z", "Z", "Y", "Y", "Z", "Z", "Y", "Z", "Y", "Z"), 6),
    p_g = rep(NA, 38 * 6),
    p_e = rep(NA, 38 * 6)
  )

  env_or_x <- c(220, 230, 700, 705, 710, 750)
  env_or_y <- c(660, 610, 450, 430, 510, 550)

  # genetic predispositions:
  x_g <- sample(1:1000, 38)
  y_g <- sample(1:1000, 38)

  # ecological availability:
  x_e <- sample(1:1000, 38)
  y_e <- sample(1:1000, 38)

  for (i in 1:6) {
    for (behav in 1:38) {
      output[output$population == list_pop[i] & output$behaviour == behav, ]$p_g <- 1 - sqrt((x_g[behav] - env_or_x[i])^2 + (y_g[behav] - env_or_y[i])^2) / 1000

      if (behav > 16) { # only for food-related behaviours:
        output[output$population == list_pop[i] & output$behaviour == behav, ]$p_e <- 1 - sqrt((x_e[behav] - env_or_x[i])^2 + (y_e[behav] - env_or_y[i])^2) / 500
      }
    }
  }

  # replace negative values with 0s:
  if (dim(output[output$p_g < 0, ])[1] > 0) {
    output[output$p_g < 0, ]$p_g <- 0
  }
  if (dim(output[output$p_e < 0 & !is.na(output$p_e), ])[1] > 0) {
    output[output$p_e < 0 & !is.na(output$p_e), ]$p_e <- 0
  }

  # return the tibble:
  output
}
```

```{r}
oranzees_environment <- set_oranzees_environment()
test_environment <- oranzees_environment %>%
  filter(population == "Uossob")
```

At this point, innovations can be made as they were done for social behaviours, with a further difference. In the calculation for social behaviour, the possible behaviour drawn with  $p_{peering}$ was then actually innovated according to its genetic propensity, $p_g$. Now we add to this $p_e$, i.e. its the ecological availability. The simplest way to do it is to multiply one for the other. 

```{r}
p_peering <- rnorm(16, mean = colSums(pop[, 1:16]), sd = 1)
p_peering[p_peering < 0] <- 0
innovation_i <- sample(1:16, 1, prob = p_peering)
p_innovate <- test_environment$p_g[innovation_i] * test_environment$p_e[innovation_i]
```

We can now, as usual, wrap everything together in a function:

```{r}
test_oranzees3 <- function(t_max) {
  oranzees_environment <- set_oranzees_environment()
  test_environment <- oranzees_environment %>%
    filter(population == "Uossob")

  N <- 100

  pop <- matrix(c(rep(0, 38 * N), sample(1:300, N, replace = TRUE)), nrow = N, byrow = FALSE)

  output <- matrix(nrow = t_max, ncol = 22)

  for (t in 1:t_max) {
    output[t, ] <- colSums(pop[, 17:38])
    # demographic bit:
    pop[, 39] <- pop[, 39] + 1
    pop[pop[, 39] >= 720, ] <- 0
    old <- which(pop[, 39] > 300)
    dead <- sample(c(TRUE, FALSE), length(old), prob = c(.01, .99), replace = TRUE)
    pop[old[dead], ] <- 0
    # innovation bit:
    for (i in 1:N) {
      nut_y <- sum(pop[i, 17:20]) + sum(pop[i, 25:27]) + sum(pop[i, 31:32]) + pop[i, 35] + pop[i, 37]
      nut_z <- sum(pop[i, 21:24]) + sum(pop[i, 28:30]) + sum(pop[i, 33:34]) + pop[i, 36] + pop[i, 38]
      state <- (sum(nut_y + nut_z) - abs(nut_y - nut_z)) / 10
      p_state <- rnorm(1, mean = 1 - state, sd = .05)
      if (runif(1) < p_state) {
        p_peering <- rnorm(22, mean = colSums(pop[, 17:38]), sd = 1)
        p_peering[p_peering < 0] <- 0
        innovation_i <- sample(17:38, 1, prob = p_peering)
        if (runif(1) < (test_environment$p_g[innovation_i] * test_environment$p_e[innovation_i])) {
          if (innovation_i <= 20) {
            pop[i, 17:20] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 20 & innovation_i <= 24) {
            pop[i, 21:24] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 24 & innovation_i <= 27) {
            pop[i, 25:27] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 27 & innovation_i <= 30) {
            pop[i, 28:30] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 30 & innovation_i <= 32) {
            pop[i, 31:32] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 32 & innovation_i <= 34) {
            pop[i, 33:34] <- 0
            pop[i, innovation_i] <- 1
          } else {
            pop[i, innovation_i] <- 1
          }
        }
      }
    }
  }
  output
}
```

Here, to run:
```{r}
t_max <- 12000
my_test <- test_oranzees3(t_max)
```

And to plot the results:

```{r warning=FALSE}
my_test <- gather(as_tibble(my_test), 1:22, key = "behaviour", value = "frequency")
data_to_plot <- tibble(
  behaviour = my_test$behaviour,
  frequency = my_test$frequency,
  time = rep(1:t_max, 22),
  category = as_factor(c(
    rep("A", t_max * 4), rep("B", t_max * 4), rep("C", t_max * 3), rep("D", t_max * 3),
    rep("E", t_max * 2), rep("F", t_max * 2), rep("G", t_max), rep("H", t_max),
    rep("I", t_max), rep("J", t_max)
  ))
)

ggplot(data = data_to_plot) +
  geom_line(aes(x = time, y = frequency, color = behaviour)) +
  facet_wrap(~category) +
  theme_bw() +
  theme(legend.position = "none")
```

***

## Multiple runs

As we did for social behaviours, we can run the simulations several times, with the same initialisation, and look at the final results. With the same logic, here the modified function `test_oranzees4()`:

```{r}
test_oranzees4 <- function(t_max) {
  N <- 100

  pop <- matrix(c(rep(0, 38 * N), sample(1:300, N, replace = TRUE)), nrow = N, byrow = FALSE)

  for (t in 1:t_max) {
    # demographic bit:
    pop[, 39] <- pop[, 39] + 1
    pop[pop[, 39] >= 720, ] <- 0
    old <- which(pop[, 39] > 300)
    dead <- sample(c(TRUE, FALSE), length(old), prob = c(.01, .99), replace = TRUE)
    pop[old[dead], ] <- 0
    # innovation bit:
    for (i in 1:N) {
      nut_y <- sum(pop[i, 17:20]) + sum(pop[i, 25:27]) + sum(pop[i, 31:32]) + pop[i, 35] + pop[i, 37]
      nut_z <- sum(pop[i, 21:24]) + sum(pop[i, 28:30]) + sum(pop[i, 33:34]) + pop[i, 36] + pop[i, 38]
      state <- (sum(nut_y + nut_z) - abs(nut_y - nut_z)) / 10
      p_state <- rnorm(1, mean = 1 - state, sd = .05)
      if (runif(1) < p_state) {
        p_peering <- rnorm(22, mean = colSums(pop[, 17:38]), sd = 1)
        p_peering[p_peering < 0] <- 0
        innovation_i <- sample(17:38, 1, prob = p_peering)
        if (runif(1) < (test_environment$p_g[innovation_i] * test_environment$p_e[innovation_i])) {
          if (innovation_i <= 20) {
            pop[i, 17:20] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 20 & innovation_i <= 24) {
            pop[i, 21:24] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 24 & innovation_i <= 27) {
            pop[i, 25:27] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 27 & innovation_i <= 30) {
            pop[i, 28:30] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 30 & innovation_i <= 32) {
            pop[i, 31:32] <- 0
            pop[i, innovation_i] <- 1
          } else if (innovation_i > 32 & innovation_i <= 34) {
            pop[i, 33:34] <- 0
            pop[i, innovation_i] <- 1
          } else {
            pop[i, innovation_i] <- 1
          }
        }
      }
    }
  }
  output <- colSums(pop[, 17:38])
}
```

And here to code to run 10 replications (as for social behaviours we are not actually running it, but we saved the data once):

```{r eval=FALSE}
oranzees_environment <- set_oranzees_environment()
test_environment <- oranzees_environment %>%
  filter(population == "Uossob")

n_run <- 10
t_max <- 12000
food_test1 <- matrix(nrow = n_run, ncol = 22)
for (run in 1:n_run) {
  food_test1[run, ] <- test_oranzees4(t_max)
}
write(t(food_test1), file = "output/food_test1.csv", ncolumns = 22)
write(test_environment$p_g[17:38], file = "output/food_test1_p_g.csv", ncolumns = 1)
write(test_environment$p_e[17:38], file = "output/food_test1_p_e.csv", ncolumns = 1)
```

We can then print the results:

```{r message=FALSE}
library(reshape2)
results <- as.matrix(read.table("output/food_test1.csv"))
colnames(results) <- 17:38

as_tibble(melt(results, varnames = c("run", "behaviour"), value.name = "frequency")) %>%
  mutate(run = as_factor(run), behaviour = as_factor(behaviour)) %>%
  add_column(category = as_factor(c(
    rep("A", 40), rep("B", 40), rep("C", 30), rep("D", 30),
    rep("E", 20), rep("F", 20), rep("G", 10), rep("H", 10),
    rep("I", 10), rep("J", 10)
  ))) %>%
  ggplot() +
  geom_raster(aes(x = behaviour, y = run, fill = frequency)) +
  facet_wrap(~category, scales = "free") +
  scale_fill_gradient(low = "grey90", high = "red") +
  theme_bw()
```

We can then visualise the correlation between the overall frequency of a behaviour and its $p_g$ value. 

```{r}
genes <- read.table("output/food_test1_p_g.csv")
tibble(
  p_g = genes$V1, total = colSums(results),
  category = as_factor(c(
    rep("A", 4), rep("B", 4), rep("C", 3), rep("D", 3),
    rep("E", 2), rep("F", 2), "G", "H", "I", "J"
  ))
) %>%
  ggplot(aes(y = total, x = p_g)) +
  geom_point() +
  facet_wrap(~category) +
  theme_bw()
```

And the same for its $p_e$ value:

```{r}
eco <- read.table("output/food_test1_p_e.csv")
tibble(
  p_e = eco$V1, total = colSums(results),
  category = as_factor(c(
    rep("A", 4), rep("B", 4), rep("C", 3), rep("D", 3),
    rep("E", 2), rep("F", 2), "G", "H", "I", "J"
  ))
) %>%
  ggplot(aes(y = total, x = p_e)) +
  geom_point() +
  facet_wrap(~category) +
  theme_bw()
```

In fact, the main effect could be their combination, i.e. $p_e*p_g$:

```{r}
tibble(
  p_e = eco$V1, p_g = genes$V1, total = colSums(results),
  category = as_factor(c(
    rep("A", 4), rep("B", 4), rep("C", 3), rep("D", 3),
    rep("E", 2), rep("F", 2), "G", "H", "I", "J"
  ))
) %>%
  ggplot(aes(y = total, x = p_e * p_g)) +
  geom_point() +
  facet_wrap(~category) +
  theme_bw()
```

The main thing to notice is that, as seen in the first figure, there is seemingly less variability with respect to social behaviours. There are many reasons why this could be the case, including more possible behaviours (10 versus 4),and categories of different size (see below), but the main is probably the fact that the results are a constrained by both $p_g$ and $p_e$, plus the need to keep a balance between nutrients, while in the case of social behaviours, they were only constrained by $p_g$

***

## Additional analyses of five sets of ten runs

To be sure that all of the above is not an idiosyncrasy of this specific set-up we run five sets of ten runs, each set with a different initial set-up, and calculate global measures (variability, effects of $p_g$ and $p_e$, and frequency of single-category behaviours). Let's first check the variability (we load the `DescTools` library, to calculate the Gini coefficient) in the first four categories (the ones with respectively four, four, three, and three behaviours):

```{r warning=FALSE}
library(DescTools)
nset <- 5
gini_sets <- tibble(category = c(rep("A", nset), rep("B", nset), rep("C", nset), rep("D", nset)), set = as_factor(rep(1:nset, 4)), gini = rep(NA, 4 * nset))
for (s in 1:nset) {
  results <- as.matrix(read.table(paste("output/food_test", s, ".csv", sep = "")))
  gini_sets[gini_sets$set == s & gini_sets$category == "A", ]$gini <- Gini(colSums(results)[1:4])
  gini_sets[gini_sets$set == s & gini_sets$category == "B", ]$gini <- Gini(colSums(results)[5:8])
  gini_sets[gini_sets$set == s & gini_sets$category == "C", ]$gini <- Gini(colSums(results)[9:11])
  gini_sets[gini_sets$set == s & gini_sets$category == "D", ]$gini <- Gini(colSums(results)[12:14])
}
ggplot(data = gini_sets, aes(y = gini, x = category, color = category)) +
  geom_boxplot(outlier.shape = NA) +
  geom_jitter(width = 0.2) +
  theme_bw() +
  coord_cartesian(ylim = c(0, 1)) +
  theme(legend.position = "none")
```

Gini coefficients are quite high. We can compare the categories A and B with the results for the 10 runs of the simulations with only social behaviours:

```{r}
gini_social <- rep(NA, 4)
results <- as.matrix(read.table("output/social_test1.csv"))
gini_social[1] <- Gini(colSums(results)[1:4])
gini_social[2] <- Gini(colSums(results)[5:8])
gini_social[3] <- Gini(colSums(results)[9:12])
gini_social[4] <- Gini(colSums(results)[13:16])
gini_social
```

The gini coefficients for the four categories of the simulation with only social behaviours tend to be lower (remember the comparable situation is with category A and B).

***

**NOTE:**
The only drawback here seems that there is not much variability, but we can parametrise the effect of $p_g$ and $p_e$. If we agree with the implementation, I'd go on this path.
