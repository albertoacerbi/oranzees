---
title: "Oranzees model"
author: "Alberto Acerbi"
date: "13/05/2019"
output: html_document

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


This Rmarkdown file documents the development of the Oranzees model. The code-only version to run the model is in the file *main.R* in the same repository.

### Spatial set-up

We first need to set-up a simulated environment where six populations of oranzees live at relative distances that are approximately similar to the six populations of chimpanzees described in Whiten et al., 1999 

We use the R package [`imager`](https://dahtah.github.io/imager/imager.html) to process a capture from Figure 1 in Whiten et al., 1999.

```{r message = FALSE}
library(imager)
chimp_env <- load.image("material/Whiten_1999_cap.png")
plot(chimp_env)
box()

```

We manually process the image to have only the six points to which we are interested, and we also reverse the y-axis (in image processing starting from zero and go negative is standard, but this is not useful for us):

```{r}

chimp_env <- load.image("material/Whiten_1999_cap2.png")
plot(chimp_env, axes = F)
axis(1)
axis(2, at = seq(-100, 400, 100), labels = seq(500, 0, -100))
grid()
box()

```

Here are the approximate locations of the oranzees populations:

```{r}

env_or_x <- c(420, 430, 900, 905, 910, 950)
env_or_y <- c(360, 310, 150, 130, 210, 250)

plot(env_or_x, env_or_y, xlim = c(0, 1200), ylim = c(0, 500), pch = 21, bg = "red")
grid()

```

For convenience, we put these locations approximately in the centre of a 1000,1000 squared environment (what is important are the relative distances, not their absolute values):

```{r}

env_or_x <- env_or_x - 200
env_or_y <- env_or_y + 300

par(pty = "s")
plot(env_or_x, env_or_y, xlim = c(0, 1000), ylim = c(0, 1000), pch = 21, bg = "red")
grid()

```

### Genetic and environmental gradients

Following again Whiten et al., 1999, we consider 38 possible behaviours. The exact charactersitics of these behaviours will be examined later. For now, we implement the idea that the probability to acquire any of these behaviours depends (among other things) by two factors:

* genetic propensity

* ecological availability 

Both are modelled as a probability $p(0,1)$, with two values: $p_g$ (genetic propensity) and $p_e$ (ecological availability).

These probabilities are assigned randomly and indpendently to each behaviours. To assign them to the different populations we use a geographical gradient. For each behaviour, a random point is chosen in the cartesian space and its distance to each population is calculated. This distance is then normalised between 0 and 1000 for the genetic propensitiy and between 0 and 500 for the ecological availability. The actual probabilities are then calcualted as $1-d_{norm}$.

Here an example:

```{r}

# generate the random point for the genetic propensity:
x_g <- sample(1:1000, 1)
y_g <- sample(1:1000, 1)

# calcualte the distance from the six populations:
d_g <- c()
for(i in 1:6) {
  d_g[i] <- sqrt((x_g - env_or_x[i])^2 + (y_g - env_or_y[i])^2)
}

```

Now we can see the random point we extracted:

```{r echo=FALSE}

c(x_g, y_g)

```

And the distances calculated:

```{r echo=FALSE}

d_g

```

Since we are working with the genetic propensity, we normalised the distance by 1000, and we then find the final probability subtracting from 1 (values that are below 0, i.e. popualtion that were at more than 1000 units distance, are considered 0):

```{r}

d_g_norm <- d_g / 1000
p_g <- 1 - d_g_norm
p_g[p_g < 0] = 0

```

Here are the final values for $p_g$:

```{r echo=FALSE}

p_g

```

An intuitive way to see this graphically is to use a gradient. The code is slighlty more complicated, but we just need to run it once to visualise the effect. We first calculate the values of $p_g$ for all the points in the environment:

```{r}

gradient_g <- matrix(nrow = 1000, ncol = 1000)

for(i in 1:1000) {
  for(j in 1:1000) {
    gradient_g[i,j] <- sqrt((x_g - i)^2 + (y_g - j)^2)
  }
}
gradient_g = 1 - gradient_g / 1000
gradient_g[gradient_g < 0] = 0 

```

And we then plot it, using the R package [`viridis`](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html), for the colour scale.

```{r message = FALSE}

library(viridis)
par(pty = "s")
image(1:1000, 1:1000, gradient_g, col = viridis(10), xlab = "env_or_x", ylab = "env_or_y")
contour(1:1000, 1:1000, gradient_g, add = TRUE) 
points(env_or_x, env_or_y, pch = 21, bg = "red")

```

We can check that the $p_g$ values of the six different populations look like the ones we showed above, just before working on the visualisation. Remember, this means that population with higher values will be more genetically predisposed to acquire one of the 38 behaviours.

We can now do the same for determining $p_e$, or the ecological availability for the same behaviour. The code is basically the same, with the only difference that the distances are normalised by 500:

```{r}

x_e <- sample(1:1000, 1)
y_e <- sample(1:1000, 1)

d_e <- c()
for(i in 1:6) {
  d_e[i] <- sqrt((x_e - env_or_x[i])^2 + (y_e - env_or_y[i])^2)
}

d_e_norm <- d_e / 500
p_e <- 1 - d_e_norm
p_e[p_e < 0] = 0

```

As before, here are the final values for $p_e$:

```{r echo=FALSE}

p_e

```

And we can visualise them, using the same tecnique:

```{r}

gradient_e <- matrix(nrow = 1000, ncol = 1000)

for(i in 1:1000) {
  for(j in 1:1000) {
    gradient_e[i,j] <- sqrt((x_e - i)^2 + (y_e - j)^2)
  }
}
gradient_e = 1 - gradient_e / 500
gradient_e[gradient_e < 0] = 0 

par(pty = "s")
image(1:1000, 1:1000, gradient_e, col = magma(10), xlab = "env_or_x", ylab = "env_or_y")
contour(1:1000, 1:1000, gradient_e, add = TRUE) 
points(env_or_x, env_or_y, pch = 21, bg = "red")

```

Again, we can check that the values in the plot correspond to the ones calculated above. The difference between the plot for genetic propensity and the plot for ecological availability illustrates the difference in the normalisation (1000 for the former and 500 for the latter). In the ecological availability plot, depending where the random point has been placed, it is more likely that some areas of the environment will be with $p_e=0$, including possibly some of our six populations. This reflects the fact that, for example, some raw materials can be availble in a population, but not in another. The likelyhood of $p_g=0$ is instead lower, reflecting that genetic constraints are less strong. This is of course a semplification, and can be changed in successive versions of the model (or perhaps be parametrised).

***

We can now wrap up everything in a function `set_oranzees_environment()` that can be use independently from what we done so far, and that we will use in the code of the actual model (*main.R*):

```{r message=FALSE}

library(tidyverse)

set_oranzees_environment <- function() {
  
  output <- tibble( population = as.factor(rep(1:6, each = 38)),
                          behaviour = as.factor(rep(1:38, 6)),
                          p_g = rep(NA, 38 * 6), 
                          p_e = rep(NA, 38 * 6))
  
  env_or_x <- c(220, 230, 700, 705, 710, 750)
  env_or_y <- c(660, 610, 450, 430, 510, 550)
  
  # genetic predispositions for the 38 behaviours:
  x_g <- sample(1:1000, 38)
  y_g <- sample(1:1000, 38)
  
  # ecological availability for the 38 behaviours:
  x_e <- sample(1:1000, 38)
  y_e <- sample(1:1000, 38)
  
  for(oranzees_pop in 1:6){
    for(behav in 1:38) {
      
      output[output$population==oranzees_pop & output$behaviour == behav,]$p_g <- 1 - sqrt((x_g[behav] - env_or_x[oranzees_pop])^2 + (y_g[behav] - env_or_y[oranzees_pop])^2)/1000
      
      output[output$population==oranzees_pop & output$behaviour == behav,]$p_e <- 1 - sqrt((x_e[behav] - env_or_x[oranzees_pop])^2 + (y_e[behav] - env_or_y[oranzees_pop])^2)/500
    }
  }
  
  # replace negative values with 0s:
  if(dim(output[output$p_g < 0, ])[1] > 0 )
    output[output$p_g < 0, ]$p_g = 0
  if(dim(output[output$p_e < 0, ])[1] > 0 )
    output[output$p_e < 0, ]$p_e = 0
  
  # return the tibble:
  output
}

```

This code does what we already did, but for all the 38 behaviours, and store everything in the `tibble` structure, provided by the library `tidyverse`. In the main code, we just need to run the function to start the set-up of a simulation:

```{r}

oranzees_environment <- set_oranzees_environment()

```

We can explore the output simply writing the name of the data structure:

```{r}

oranzees_environment

```
